{"version":3,"sources":["../../../../../src/steps/source-nodes/update-nodes/wp-actions/index.js"],"names":["previouslyFetchedActionIds","getWpActions","variables","helpers","throwFetchErrors","throwGqlErrors","sourceTime","Date","now","actionMonitorActions","contentTypePlural","query","actionMonitorQuery","nodeTypeName","length","actionsSinceLastUpdate","filter","id","includes","forEach","push","cache","set","LAST_COMPLETED_SOURCE_TIME","actionabledIds","actions","action","referencedNodeGlobalRelayID","actionExists","find","actionableId","handleWpActions","api","cachedNodeIds","wpAction","actionType","fetchAndRunWpActions","pluginOptions","intervalRefetching","since","wpActions","didUpdate"],"mappings":"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","sourcesContent":["import { actionMonitorQuery } from \"~/utils/graphql-queries\"\nimport wpActionDELETE from \"./delete\"\nimport wpActionUPDATE from \"./update\"\nimport { LAST_COMPLETED_SOURCE_TIME } from \"~/constants\"\nimport { paginatedWpNodeFetch } from \"~/steps/source-nodes/fetch-nodes/fetch-nodes-paginated\"\n\nimport fetchAndCreateNonNodeRootFields from \"~/steps/source-nodes/create-nodes/fetch-and-create-non-node-root-fields\"\nimport { setHardCachedNodes } from \"~/utils/cache\"\n\nconst previouslyFetchedActionIds = []\n\n/**\n * getWpActions\n *\n * pull the latest changes from WP and determine which of those changes\n * require updates in Gatsby, then return valid changes\n * An example of a non-valid change would be a post that was created\n * and then immediately deleted.\n */\nexport const getWpActions = async ({\n  variables,\n  helpers,\n  throwFetchErrors = false,\n  throwGqlErrors = false,\n}) => {\n  // current time minus 5 seconds so we don't lose updates between the cracks\n  // if someone bulk-edits a list of nodes in WP\n  // @todo make this cursor based so we don't need to do this.\n  // give me changes since x change. if x change doesn't exist,\n  // then we need to fetch everything\n  const sourceTime = Date.now() - 5000\n\n  // @todo add pagination in case there are more than 100 actions since the last build\n  const actionMonitorActions = await paginatedWpNodeFetch({\n    contentTypePlural: `actionMonitorActions`,\n    query: actionMonitorQuery,\n    nodeTypeName: `ActionMonitor`,\n    helpers,\n    throwFetchErrors,\n    throwGqlErrors,\n    ...variables,\n  })\n\n  if (!actionMonitorActions || !actionMonitorActions.length) {\n    return []\n  }\n\n  const actionsSinceLastUpdate = actionMonitorActions.filter(\n    // remove any actions that were fetched in the last run\n    // (only needed in develop but doesn't hurt in production as previouslyFetchedActionIds will always be empty in prod)\n    ({ id }) => !previouslyFetchedActionIds.includes(id)\n  )\n\n  // store these action ids so we don't run them again if we're interval refetching\n  actionsSinceLastUpdate.forEach(({ id }) =>\n    previouslyFetchedActionIds.push(id)\n  )\n\n  await helpers.cache.set(LAST_COMPLETED_SOURCE_TIME, sourceTime)\n\n  // @todo - rework this logic, and make sure it works as expected in all cases.\n  // we only want to use the latest action on each post ID in case multiple\n  // actions were recorded for the same post\n  // for example: if a post was deleted and then immediately published again.\n  // if we kept both actions we would download the node and then delete it\n  // Since we receive the actions in order from newest to oldest, we\n  // can prefer actions at the top of the list.\n  const actionabledIds = []\n  const actions = actionsSinceLastUpdate.filter((action) => {\n    const id = action.referencedNodeGlobalRelayID\n\n    // check if an action with the same id exists\n    const actionExists = actionabledIds.find(\n      (actionableId) => actionableId === id\n    )\n\n    // if there isn't one, record the id of this one to filter\n    // out further actions with the same id\n    if (!actionExists) {\n      actionabledIds.push(id)\n    }\n\n    // just keep the action if one doesn't already exist\n    return !actionExists\n  })\n\n  return actions\n}\n\n/**\n * Acts on changes in WordPress to call functions that sync Gatsby with\n * the latest WP changes\n */\nexport const handleWpActions = async (api) => {\n  let { cachedNodeIds, helpers } = api\n\n  switch (api.wpAction.actionType) {\n    case `DELETE`:\n      await wpActionDELETE(api)\n      break\n    case `UPDATE`:\n    case `CREATE`:\n      await wpActionUPDATE(api)\n      break\n    case `NON_NODE_ROOT_FIELDS`:\n      await fetchAndCreateNonNodeRootFields()\n  }\n\n  await setHardCachedNodes({ helpers })\n\n  return cachedNodeIds\n}\n\n/**\n * fetchAndRunWpActions\n *\n * fetches a list of latest changes in WordPress\n * and then acts on those changes\n */\nexport const fetchAndRunWpActions = async ({\n  helpers,\n  pluginOptions,\n  intervalRefetching,\n  since,\n  throwFetchErrors = false,\n  throwGqlErrors = false,\n}) => {\n  // check for new, edited, or deleted posts in WP \"Action Monitor\"\n  const wpActions = await getWpActions({\n    variables: {\n      since,\n    },\n    helpers,\n    throwFetchErrors,\n    throwGqlErrors,\n  })\n\n  const didUpdate = !!wpActions.length\n\n  if (didUpdate) {\n    for (const wpAction of wpActions) {\n      // Create, update, and delete nodes\n      await handleWpActions({\n        helpers,\n        pluginOptions,\n        intervalRefetching,\n        wpAction,\n      })\n    }\n  }\n\n  return {\n    wpActions,\n    didUpdate,\n  }\n}\n"],"file":"index.js"}