{"version":3,"sources":["../../../../src/steps/source-nodes/update-nodes/content-update-interval.js"],"names":["refetcher","msRefetchInterval","helpers","reconnectionActivity","retryCount","intervalRefetching","throwFetchErrors","throwGqlErrors","end","reporter","success","e","pluginOptions","debug","throwRefetchErrors","activityTimer","message","start","setStatus","retryTime","maxWait","waitFor","Promise","resolve","setTimeout","startPollingForContentUpdates","process","env","WP_DISABLE_POLLING","verbose","store","getState","gatsbyApi","develop","nodeUpdateInterval","log","info"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,MAAMA,SAAS,GAAG,OAChBC,iBADgB,EAEhBC,OAFgB,EAGhB;AAAEC,EAAAA,oBAAoB,GAAG,IAAzB;AAA+BC,EAAAA,UAAU,GAAG;AAA5C,IAAkD,EAHlC,KAIb;AACH,MAAI;AACF,UAAM,+BAAyB;AAC7BC,MAAAA,kBAAkB,EAAE,IADS;AAE7BC,MAAAA,gBAAgB,EAAE,IAFW;AAG7BC,MAAAA,cAAc,EAAE;AAHa,KAAzB,CAAN;;AAMA,QAAIJ,oBAAJ,EAA0B;AACxBA,MAAAA,oBAAoB,CAACK,GAArB;AACAN,MAAAA,OAAO,CAACO,QAAR,CAAiBC,OAAjB,CACE,wCACG,sCAAqCN,UAAW,IAC/CA,UAAU,KAAK,CAAf,GAAoB,KAApB,GAA4B,OAC7B,EAHH,CADF;AAQAD,MAAAA,oBAAoB,GAAG,IAAvB;AACAC,MAAAA,UAAU,GAAG,CAAb;AACD;AACF,GApBD,CAoBE,OAAOO,CAAP,EAAU;AAAA;;AACV,UAAM;AAAEC,MAAAA;AAAF,QAAoB,iCAA1B;;AACA,QAAIA,aAAJ,aAAIA,aAAJ,+CAAIA,aAAa,CAAEC,KAAnB,yDAAI,qBAAsBC,kBAA1B,EAA8C;AAC5C,YAAMH,CAAN;AACD;;AAED,QAAI,CAACR,oBAAL,EAA2B;AACzBA,MAAAA,oBAAoB,GAAGD,OAAO,CAACO,QAAR,CAAiBM,aAAjB,CACrB,wCAAkB,0BAAyBJ,CAAC,CAACK,OAAQ,GAArD,CADqB,CAAvB;AAGAb,MAAAA,oBAAoB,CAACc,KAArB;AACAd,MAAAA,oBAAoB,CAACe,SAArB,CAAgC,aAAhC;AACD,KAND,MAMO;AACLd,MAAAA,UAAU;AACVD,MAAAA,oBAAoB,CAACe,SAArB,CAAgC,WAAUd,UAAW,QAArD;AACD,KAfS,CAiBV;;;AACA,UAAMe,SAAS,GAAGf,UAAU,GAAG,IAA/B,CAlBU,CAmBV;AACA;;AACA,UAAMgB,OAAO,GAAG,KAAhB;AACA,UAAMC,OAAO,GAAGF,SAAS,IAAIC,OAAb,GAAuBA,OAAvB,GAAiCD,SAAjD;AAEA,UAAM,IAAIG,OAAJ,CAAaC,OAAD,IAAaC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAnC,CAAN;AACD;;AAEDG,EAAAA,UAAU,CACR,MACExB,SAAS,CAACC,iBAAD,EAAoBC,OAApB,EAA6B;AACpCC,IAAAA,oBADoC;AAEpCC,IAAAA;AAFoC,GAA7B,CAFH,EAMRH,iBANQ,CAAV;AAQD,CA5DD;AA8DA;;;;;;AAIA,MAAMwB,6BAA6B,GAAG,CAACvB,OAAD,EAAUU,aAAV,KAA4B;AAChE,MAAIc,OAAO,CAACC,GAAR,CAAYC,kBAAhB,EAAoC;AAClC;AACD;;AAED,QAAM;AAAEC,IAAAA;AAAF,MAAcC,eAAMC,QAAN,GAAiBC,SAAjB,CAA2BpB,aAA/C;;AAEA,QAAMX,iBAAiB,GACrBW,aAAa,IACbA,aAAa,CAACqB,OADd,IAEArB,aAAa,CAACqB,OAAd,CAAsBC,kBAFtB,GAGItB,aAAa,CAACqB,OAAd,CAAsBC,kBAH1B,GAII,GALN;;AAOA,MAAIL,OAAJ,EAAa;AACX3B,IAAAA,OAAO,CAACO,QAAR,CAAiB0B,GAAjB,CAAsB,EAAtB;AACAjC,IAAAA,OAAO,CAACO,QAAR,CAAiB2B,IAAjB,CAAsB,uCAAiB,gCAAvC;AACD;;AAEDpC,EAAAA,SAAS,CAACC,iBAAD,EAAoBC,OAApB,CAAT;AACD,CApBD","sourcesContent":["import fetchAndApplyNodeUpdates from \"./fetch-node-updates\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport store from \"~/store\"\nimport { getGatsbyApi } from \"~/utils/get-gatsby-api\"\n\nconst refetcher = async (\n  msRefetchInterval,\n  helpers,\n  { reconnectionActivity = null, retryCount = 1 } = {}\n) => {\n  try {\n    await fetchAndApplyNodeUpdates({\n      intervalRefetching: true,\n      throwFetchErrors: true,\n      throwGqlErrors: true,\n    })\n\n    if (reconnectionActivity) {\n      reconnectionActivity.end()\n      helpers.reporter.success(\n        formatLogMessage(\n          `Content updates re-connected after ${retryCount} ${\n            retryCount === 1 ? `try` : `tries`\n          }`\n        )\n      )\n\n      reconnectionActivity = null\n      retryCount = 1\n    }\n  } catch (e) {\n    const { pluginOptions } = getGatsbyApi()\n    if (pluginOptions?.debug?.throwRefetchErrors) {\n      throw e\n    }\n\n    if (!reconnectionActivity) {\n      reconnectionActivity = helpers.reporter.activityTimer(\n        formatLogMessage(`Content update error: \"${e.message}\"`)\n      )\n      reconnectionActivity.start()\n      reconnectionActivity.setStatus(`retrying...`)\n    } else {\n      retryCount++\n      reconnectionActivity.setStatus(`retried ${retryCount} times`)\n    }\n\n    // retry after retry count times 5 seconds\n    const retryTime = retryCount * 5000\n    // if the retry time is greater than or equal to the max (60 seconds)\n    // use the max, otherwise use the retry time\n    const maxWait = 60000\n    const waitFor = retryTime >= maxWait ? maxWait : retryTime\n\n    await new Promise((resolve) => setTimeout(resolve, waitFor))\n  }\n\n  setTimeout(\n    () =>\n      refetcher(msRefetchInterval, helpers, {\n        reconnectionActivity,\n        retryCount,\n      }),\n    msRefetchInterval\n  )\n}\n\n/**\n * Starts constantly refetching the latest WordPress changes\n * so we can update Gatsby nodes when data changes\n */\nconst startPollingForContentUpdates = (helpers, pluginOptions) => {\n  if (process.env.WP_DISABLE_POLLING) {\n    return\n  }\n\n  const { verbose } = store.getState().gatsbyApi.pluginOptions\n\n  const msRefetchInterval =\n    pluginOptions &&\n    pluginOptions.develop &&\n    pluginOptions.develop.nodeUpdateInterval\n      ? pluginOptions.develop.nodeUpdateInterval\n      : 300\n\n  if (verbose) {\n    helpers.reporter.log(``)\n    helpers.reporter.info(formatLogMessage`Watching for WordPress changes`)\n  }\n\n  refetcher(msRefetchInterval, helpers)\n}\n\nexport { startPollingForContentUpdates }\n"],"file":"content-update-interval.js"}