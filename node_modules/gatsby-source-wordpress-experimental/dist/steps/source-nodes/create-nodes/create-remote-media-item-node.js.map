{"version":3,"sources":["../../../../src/steps/source-nodes/create-nodes/create-remote-media-item-node.js"],"names":["getFileNodeMetaBySourceUrl","sourceUrl","fileNodesMetaByUrls","store","getState","imageNodes","nodeMetaByUrl","getMediaItemEditLink","node","protocol","hostname","url","parse","link","editUrl","databaseId","errorPanicker","error","reporter","fetchState","parentName","sharedError","mediaItemUrl","process","env","NODE_ENV","includes","shouldBail","log","warn","info","panic","getFileNodeByMediaItemNode","mediaItemNode","helpers","modifiedGmt","fileUrl","existingNodeMeta","id","getNode","internal","type","localFile","createRemoteMediaItemNode","state","pluginOptions","gatsbyApi","existingNode","gatsbyStore","cache","createNodeId","actions","createNode","mimeType","title","wpUrl","remoteSchema","src","excludeByMimeTypes","MediaItem","hardCachedFileRelativePath","hardCachedMediaFilesDirectory","cwd","hardCachedFilePath","hardCacheMediaFiles","develop","production","remoteFileNode","createFileNodeRequirements","parentNodeId","buffer","fs","readFile","name","ext","path","extname","e","wpUrlHostname","mediaItemHostname","htaccessCredentials","auth","htaccess","shouldUseHtaccessCredentials","htaccess_pass","password","htaccess_user","username","retries","factor","minTimeout","onRetry","dispatch","pushNodeMeta","ensureDir","dirname","copyFile","absolutePath"],"mappings":"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","sourcesContent":["import fs from \"fs-extra\"\nimport path from \"path\"\nimport url from \"url\"\n\nimport retry from \"async-retry\"\n\nimport { createFileNodeFromBuffer } from \"gatsby-source-filesystem\"\n\nimport createRemoteFileNode from \"./create-remote-file-node/index\"\n\nimport store from \"~/store\"\n\nimport urlToPath from \"~/utils/url-to-path\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport { stripImageSizesFromUrl } from \"~/steps/source-nodes/fetch-nodes/fetch-referenced-media-items\"\nimport { ensureSrcHasHostname } from \"./process-node\"\n\nexport const getFileNodeMetaBySourceUrl = (sourceUrl) => {\n  const fileNodesMetaByUrls = store.getState().imageNodes.nodeMetaByUrl\n\n  return fileNodesMetaByUrls[stripImageSizesFromUrl(sourceUrl)]\n}\n\nexport const getMediaItemEditLink = (node) => {\n  const { protocol, hostname } = url.parse(node.link)\n  const editUrl = `${protocol}//${hostname}/wp-admin/upload.php?item=${node.databaseId}`\n\n  return editUrl\n}\n\nexport const errorPanicker = ({\n  error,\n  reporter,\n  node,\n  fetchState,\n  parentName,\n}) => {\n  const editUrl = getMediaItemEditLink(node)\n  const sharedError = `occured while fetching media item #${node.databaseId}${\n    parentName ? ` in step:\\n\\n\"${parentName}\"` : ``\n  }\\n\\nMedia item link: ${node.link}\\nEdit link: ${editUrl}\\nFile url: ${\n    node.mediaItemUrl\n  }`\n\n  if (\n    process.env.NODE_ENV !== `production` &&\n    error.includes(`Response code 404`)\n  ) {\n    fetchState.shouldBail = true\n    reporter.log(``)\n    reporter.warn(\n      formatLogMessage(\n        `Error ${sharedError}\\n\\nThis error will fail production builds.`\n      )\n    )\n    reporter.log(``)\n    return\n  }\n\n  if (\n    error.includes(`Response code 4`) ||\n    error.includes(`Response code 500`) ||\n    error.includes(`Response code 511`) ||\n    error.includes(`Response code 508`) ||\n    error.includes(`Response code 505`) ||\n    error.includes(`Response code 501`)\n  ) {\n    reporter.log(``)\n    reporter.info(\n      formatLogMessage(\n        `Unrecoverable error ${sharedError}\\n\\nFailing the build to prevent deploying a broken site.`\n      )\n    )\n    reporter.panic(error)\n  }\n}\n\nexport const getFileNodeByMediaItemNode = async ({\n  mediaItemNode,\n  helpers,\n}) => {\n  const { sourceUrl, modifiedGmt, mediaItemUrl, databaseId } = mediaItemNode\n\n  const fileUrl = sourceUrl || mediaItemUrl\n\n  if (!fileUrl) {\n    helpers.reporter.warn(\n      formatLogMessage(`Couldn't find source url for media item #${databaseId}`)\n    )\n    return null\n  }\n\n  const existingNodeMeta = getFileNodeMetaBySourceUrl(fileUrl)\n\n  if (\n    // if we already have this image\n    existingNodeMeta &&\n    existingNodeMeta.id &&\n    // and it hasn't been modified\n    existingNodeMeta.modifiedGmt === modifiedGmt\n  ) {\n    let node = await helpers.getNode(existingNodeMeta.id)\n\n    // some of the cached node metas dont necessarily need to be a File\n    // so make sure we return a File node if what we get isn't one\n    if (node && node.internal && node.internal.type !== `File`) {\n      if (node.localFile && node.localFile.id) {\n        // look up the corresponding file node\n        node = await helpers.getNode(node.localFile.id)\n      } else {\n        return null\n      }\n    }\n\n    return node\n  }\n\n  return null\n}\n\nexport const createRemoteMediaItemNode = async ({\n  mediaItemNode,\n  parentName,\n}) => {\n  const state = store.getState()\n  const { helpers, pluginOptions } = state.gatsbyApi\n\n  const existingNode = await getFileNodeByMediaItemNode({\n    mediaItemNode,\n    helpers,\n  })\n\n  if (existingNode) {\n    return existingNode\n  }\n\n  const {\n    store: gatsbyStore,\n    cache,\n    createNodeId,\n    reporter,\n    actions: { createNode },\n  } = helpers\n\n  let { mediaItemUrl, modifiedGmt, mimeType, title } = mediaItemNode\n\n  if (!mediaItemUrl) {\n    return null\n  }\n\n  const { wpUrl } = state.remoteSchema\n  mediaItemUrl = ensureSrcHasHostname({ wpUrl, src: mediaItemUrl })\n\n  const { excludeByMimeTypes } = pluginOptions.type?.MediaItem?.localFile\n\n  // if this type of file is excluded, don't fetch the remote file\n  if (excludeByMimeTypes.includes(mimeType)) {\n    return null\n  }\n\n  const hardCachedFileRelativePath = urlToPath(mediaItemUrl)\n  const hardCachedMediaFilesDirectory = `${process.cwd()}/.wordpress-cache`\n\n  const hardCachedFilePath =\n    hardCachedMediaFilesDirectory + hardCachedFileRelativePath\n\n  const hardCacheMediaFiles =\n    (process.env.NODE_ENV === `development` &&\n      pluginOptions.develop.hardCacheMediaFiles) ||\n    (process.env.NODE_ENV === `production` &&\n      pluginOptions.production.hardCacheMediaFiles)\n\n  let fetchState = {\n    shouldBail: false,\n  }\n  // Otherwise we need to download it\n  const remoteFileNode = await retry(\n    async () => {\n      if (fetchState.shouldBail) {\n        return null\n      }\n\n      const createFileNodeRequirements = {\n        parentNodeId: mediaItemNode.id,\n        store: gatsbyStore,\n        cache,\n        createNode,\n        createNodeId,\n        reporter,\n      }\n\n      if (hardCacheMediaFiles) {\n        // check for file in .wordpress-cache/wp-content\n        // if it exists, use that to create a node from instead of\n        // fetching from wp\n        try {\n          const buffer = await fs.readFile(hardCachedFilePath)\n          const node = await createFileNodeFromBuffer({\n            buffer,\n            name: title,\n            ext: path.extname(mediaItemUrl),\n            ...createFileNodeRequirements,\n          })\n\n          if (node) {\n            return node\n          }\n        } catch (e) {\n          // ignore errors, we'll download the image below if it doesn't exist\n        }\n      }\n\n      const { hostname: wpUrlHostname } = url.parse(wpUrl)\n      const { hostname: mediaItemHostname } = url.parse(mediaItemUrl)\n\n      const htaccessCredentials = pluginOptions.auth.htaccess\n\n      // if media items are hosted on another url like s3,\n      // using the htaccess creds will throw 400 errors\n      const shouldUseHtaccessCredentials = wpUrlHostname === mediaItemHostname\n\n      const auth =\n        htaccessCredentials && shouldUseHtaccessCredentials\n          ? {\n              htaccess_pass: htaccessCredentials?.password,\n              htaccess_user: htaccessCredentials?.username,\n            }\n          : null\n\n      // if this errors, it's caught one level above in fetch-referenced-media-items.js so it can be placed on the end of the request queue\n      const node = await createRemoteFileNode({\n        url: mediaItemUrl,\n        auth,\n        ...createFileNodeRequirements,\n      })\n\n      return node\n    },\n    {\n      retries: 3,\n      factor: 1.1,\n      minTimeout: 5000,\n      onRetry: (error) =>\n        errorPanicker({\n          error,\n          reporter,\n          node: mediaItemNode,\n          fetchState,\n          parentName,\n        }),\n    }\n  )\n\n  if (!remoteFileNode) {\n    return null\n  }\n\n  // push it's id and url to our store for caching,\n  // so we can touch this node next time\n  // and so we can easily access the id by source url later\n  store.dispatch.imageNodes.pushNodeMeta({\n    id: remoteFileNode.id,\n    sourceUrl: mediaItemUrl,\n    modifiedGmt,\n  })\n\n  if (hardCacheMediaFiles) {\n    try {\n      // make sure the directory exists\n      await fs.ensureDir(path.dirname(hardCachedFilePath))\n      // copy our downloaded file to our existing directory\n      await fs.copyFile(remoteFileNode.absolutePath, hardCachedFilePath)\n    } catch (e) {\n      helpers.reporter.panic(e)\n    }\n  }\n\n  // and use it\n  return remoteFileNode\n}\n"],"file":"create-remote-media-item-node.js"}