{"version":3,"sources":["../../../../../src/steps/source-nodes/create-nodes/create-remote-file-node/index.js"],"names":["fs","require","remoteFileDownloaderBarPromise","got","createContentDigest","path","isWebUri","Queue","readChunk","fileType","createProgress","createFileNode","getRemoteFileExtension","getRemoteFileName","createFilePath","cacheId","url","bar","totalJobs","STALL_RETRY_LIMIT","STALL_TIMEOUT","CONNECTION_RETRY_LIMIT","CONNECTION_TIMEOUT","queue","pushToQueue","id","merge","old","_","cb","concurrent","process","env","GATSBY_CONCURRENT_DOWNLOAD","doneQueueTimeout","awaitingCreateRemoteFileNodePromise","on","setTimeout","done","task","node","processRemoteNode","e","requestRemoteNode","headers","tmpFilename","httpOpts","attempt","Promise","resolve","reject","timeout","handleTimeout","fsWriteStream","close","removeSync","processingCache","total","resetTimeout","clearTimeout","responseStream","stream","retries","createWriteStream","pipe","error","response","cache","createNode","parentNodeId","auth","httpHeaders","createNodeId","ext","name","pluginCacheDir","directory","cachedHeaders","get","etag","htaccess_pass","htaccess_user","digest","statusCode","set","buffer","sync","minimumBytes","filetype","filename","join","String","move","overwrite","remove","fileNode","internal","description","parent","pushTask","push","err","module","exports","getCache","reporter","decodeURI","encodeURI","Error","undefined","start","fileDownloadPromise","then","tick"],"mappings":"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","sourcesContent":["const fs = require(`fs-extra`)\nimport btoa from \"btoa\"\nconst { remoteFileDownloaderBarPromise } = require(\"./progress-bar-promise\")\nconst got = require(`got`)\nconst { createContentDigest } = require(`gatsby-core-utils`)\nconst path = require(`path`)\nconst { isWebUri } = require(`valid-url`)\nconst Queue = require(`better-queue`)\nconst readChunk = require(`read-chunk`)\nconst fileType = require(`file-type`)\nconst { createProgress } = require(`gatsby-source-filesystem/utils`)\n\nconst { createFileNode } = require(`gatsby-source-filesystem/create-file-node`)\nconst {\n  getRemoteFileExtension,\n  getRemoteFileName,\n  createFilePath,\n} = require(`gatsby-source-filesystem/utils`)\nconst cacheId = (url) => `create-remote-file-node-${url}`\n\nlet bar\n// Keep track of the total number of jobs we push in the queue\nlet totalJobs = 0\n\n/********************\n * Type Definitions *\n ********************/\n\n/**\n * @typedef {GatsbyCache}\n * @see gatsby/packages/gatsby/utils/cache.js\n */\n\n/**\n * @typedef {Reporter}\n * @see gatsby/packages/gatsby-cli/lib/reporter.js\n */\n\n/**\n * @typedef {Auth}\n * @type {Object}\n * @property {String} htaccess_pass\n * @property {String} htaccess_user\n */\n\n/**\n * @typedef {CreateRemoteFileNodePayload}\n * @typedef {Object}\n * @description Create Remote File Node Payload\n *\n * @param  {String} options.url\n * @param  {GatsbyCache} options.cache\n * @param  {Function} options.createNode\n * @param  {Function} options.getCache\n * @param  {Auth} [options.auth]\n * @param  {Reporter} [options.reporter]\n */\n\nconst STALL_RETRY_LIMIT = 3\nconst STALL_TIMEOUT = 30000\n\nconst CONNECTION_RETRY_LIMIT = 5\nconst CONNECTION_TIMEOUT = 30000\n\n/********************\n * Queue Management *\n ********************/\n\n/**\n * Queue\n * Use the task's url as the id\n * When pushing a task with a similar id, prefer the original task\n * as it's already in the processing cache\n */\nconst queue = new Queue(pushToQueue, {\n  id: `url`,\n  merge: (old, _, cb) => cb(old),\n  concurrent: process.env.GATSBY_CONCURRENT_DOWNLOAD || 200,\n})\n\nlet doneQueueTimeout\n\nlet awaitingCreateRemoteFileNodePromise\n\n// when the queue is empty we stop the progressbar\nqueue.on(`drain`, async () => {\n  if (awaitingCreateRemoteFileNodePromise) {\n    return\n  }\n\n  awaitingCreateRemoteFileNodePromise = true\n  await remoteFileDownloaderBarPromise\n  awaitingCreateRemoteFileNodePromise = false\n\n  if (bar) {\n    // this is to give us a little time to wait and see if there\n    // will be more jobs added with a break between\n    // sometimes the queue empties but then is recreated within 2 secs\n    doneQueueTimeout = setTimeout(() => {\n      bar.done()\n      totalJobs = 0\n    }, 2000)\n  }\n})\n\n/**\n * @callback {Queue~queueCallback}\n * @param {*} error\n * @param {*} result\n */\n\n/**\n * pushToQueue\n * --\n * Handle tasks that are pushed in to the Queue\n *\n *\n * @param  {CreateRemoteFileNodePayload}          task\n * @param  {Queue~queueCallback}  cb\n * @return {Promise<null>}\n */\nasync function pushToQueue(task, cb) {\n  try {\n    const node = await processRemoteNode(task)\n    return cb(null, node)\n  } catch (e) {\n    return cb(e)\n  }\n}\n\n/******************\n * Core Functions *\n ******************/\n\n/**\n * requestRemoteNode\n * --\n * Download the requested file\n *\n * @param  {String}   url\n * @param  {Headers}  headers\n * @param  {String}   tmpFilename\n * @param  {Object}   httpOpts\n * @param  {number}   attempt\n * @return {Promise<Object>}  Resolves with the [http Result Object]{@link https://nodejs.org/api/http.html#http_class_http_serverresponse}\n */\nconst requestRemoteNode = (url, headers, tmpFilename, httpOpts, attempt = 1) =>\n  new Promise((resolve, reject) => {\n    let timeout\n\n    // Called if we stall for 30s without receiving any data\n    const handleTimeout = async () => {\n      fsWriteStream.close()\n      fs.removeSync(tmpFilename)\n      if (attempt < STALL_RETRY_LIMIT) {\n        // Retry by calling ourself recursively\n        resolve(\n          requestRemoteNode(url, headers, tmpFilename, httpOpts, attempt + 1)\n        )\n      } else {\n        processingCache[url] = null\n        totalJobs -= 1\n        bar.total = totalJobs\n        reject(`Failed to download ${url} after ${STALL_RETRY_LIMIT} attempts`)\n      }\n    }\n\n    const resetTimeout = () => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      timeout = setTimeout(handleTimeout, STALL_TIMEOUT)\n    }\n    const responseStream = got.stream(url, {\n      headers,\n      timeout: CONNECTION_TIMEOUT,\n      retries: CONNECTION_RETRY_LIMIT,\n      ...httpOpts,\n    })\n    const fsWriteStream = fs.createWriteStream(tmpFilename)\n    responseStream.pipe(fsWriteStream)\n\n    // If there's a 400/500 response or other error.\n    responseStream.on(`error`, (error) => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      processingCache[url] = null\n      totalJobs -= 1\n      bar.total = totalJobs\n      fs.removeSync(tmpFilename)\n      reject(error)\n    })\n\n    fsWriteStream.on(`error`, (error) => {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      processingCache[url] = null\n      totalJobs -= 1\n      bar.total = totalJobs\n      reject(error)\n    })\n\n    responseStream.on(`response`, (response) => {\n      resetTimeout()\n\n      fsWriteStream.on(`finish`, () => {\n        if (timeout) {\n          clearTimeout(timeout)\n        }\n        resolve(response)\n      })\n    })\n  })\n\n/**\n * processRemoteNode\n * --\n * Request the remote file and return the fileNode\n *\n * @param {CreateRemoteFileNodePayload} options\n * @return {Promise<Object>} Resolves with the fileNode\n */\nasync function processRemoteNode({\n  url,\n  cache,\n  createNode,\n  parentNodeId,\n  auth = {},\n  httpHeaders = {},\n  createNodeId,\n  ext,\n  name,\n}) {\n  const pluginCacheDir = cache.directory\n  // See if there's response headers for this url\n  // from a previous request.\n  const cachedHeaders = await cache.get(cacheId(url))\n\n  const headers = { ...httpHeaders }\n  if (cachedHeaders && cachedHeaders.etag) {\n    headers[`If-None-Match`] = cachedHeaders.etag\n  }\n\n  // Add htaccess authentication if passed in. This isn't particularly\n  // extensible. We should define a proper API that we validate.\n  const httpOpts = {}\n  if (auth?.htaccess_pass && auth?.htaccess_user) {\n    headers[`Authorization`] = `Basic ${btoa(\n      `${auth.htaccess_user}:${auth.htaccess_pass}`\n    )}`\n  }\n\n  // Create the temp and permanent file names for the url.\n  const digest = createContentDigest(url)\n  if (!name) {\n    name = getRemoteFileName(url)\n  }\n  if (!ext) {\n    ext = getRemoteFileExtension(url)\n  }\n\n  const tmpFilename = createFilePath(pluginCacheDir, `tmp-${digest}`, ext)\n\n  // Fetch the file.\n  const response = await requestRemoteNode(url, headers, tmpFilename, httpOpts)\n\n  if (response.statusCode == 200) {\n    // Save the response headers for future requests.\n    await cache.set(cacheId(url), response.headers)\n  }\n\n  // If the user did not provide an extension and we couldn't get one from remote file, try and guess one\n  if (ext === ``) {\n    const buffer = readChunk.sync(tmpFilename, 0, fileType.minimumBytes)\n    const filetype = fileType(buffer)\n    if (filetype) {\n      ext = `.${filetype.ext}`\n    }\n  }\n\n  const filename = createFilePath(\n    path.join(pluginCacheDir, digest),\n    String(name),\n    ext\n  )\n\n  // If the status code is 200, move the piped temp file to the real name.\n  if (response.statusCode === 200) {\n    await fs.move(tmpFilename, filename, { overwrite: true })\n    // Else if 304, remove the empty response.\n  } else {\n    processingCache[url] = null\n    totalJobs -= 1\n\n    bar.total = totalJobs\n\n    await fs.remove(tmpFilename)\n  }\n\n  // Create the file node.\n  const fileNode = await createFileNode(filename, createNodeId, {})\n  fileNode.internal.description = `File \"${url}\"`\n  fileNode.url = url\n  fileNode.parent = parentNodeId\n  // Override the default plugin as gatsby-source-filesystem needs to\n  // be the owner of File nodes or there'll be conflicts if any other\n  // File nodes are created through normal usages of\n  // gatsby-source-filesystem.\n  await createNode(fileNode, { name: `gatsby-source-filesystem` })\n\n  return fileNode\n}\n\n/**\n * Index of promises resolving to File node from remote url\n */\nconst processingCache = {}\n/**\n * pushTask\n * --\n * pushes a task in to the Queue and the processing cache\n *\n * Promisfy a task in queue\n * @param {CreateRemoteFileNodePayload} task\n * @return {Promise<Object>}\n */\nconst pushTask = (task) =>\n  new Promise((resolve, reject) => {\n    queue\n      .push(task)\n      .on(`finish`, (task) => {\n        resolve(task)\n      })\n      .on(`failed`, (err) => {\n        reject(`failed to process ${task.url}\\n${err}`)\n      })\n  })\n\n/***************\n * Entry Point *\n ***************/\n\n/**\n * createRemoteFileNode\n * --\n *\n * Download a remote file\n * First checks cache to ensure duplicate requests aren't processed\n * Then pushes to a queue\n *\n * @param {CreateRemoteFileNodePayload} options\n * @return {Promise<Object>}                  Returns the created node\n */\nmodule.exports = ({\n  url,\n  cache,\n  createNode,\n  getCache,\n  parentNodeId = null,\n  auth = {},\n  httpHeaders = {},\n  createNodeId,\n  ext = null,\n  name = null,\n  reporter,\n}) => {\n  if (doneQueueTimeout) {\n    // this is to give the bar a little time to wait when there are pauses\n    // between file downloads.\n    clearTimeout(doneQueueTimeout)\n  }\n\n  // if the url isn't already encoded\n  // so decoding it doesn't do anything\n  if (decodeURI(url) === url) {\n    // encode the uri\n    // this accounts for special characters in filenames\n    url = encodeURI(url)\n  }\n\n  // validation of the input\n  // without this it's notoriously easy to pass in the wrong `createNodeId`\n  // see gatsbyjs/gatsby#6643\n  if (typeof createNodeId !== `function`) {\n    throw new Error(\n      `createNodeId must be a function, was ${typeof createNodeId}`\n    )\n  }\n  if (typeof createNode !== `function`) {\n    throw new Error(`createNode must be a function, was ${typeof createNode}`)\n  }\n  if (typeof getCache === `function`) {\n    // use cache of this plugin and not cache of function caller\n    cache = getCache(`gatsby-source-filesystem`)\n  }\n  if (typeof cache !== `object`) {\n    throw new Error(\n      `Neither \"cache\" or \"getCache\" was passed. getCache must be function that return Gatsby cache, \"cache\" must be the Gatsby cache, was ${typeof cache}`\n    )\n  }\n\n  // Check if we already requested node for this remote file\n  // and return stored promise if we did.\n  if (processingCache[url]) {\n    return processingCache[url]\n  }\n\n  if (!url || isWebUri(url) === undefined) {\n    return Promise.reject(\n      `url passed to create-remote-file-node is either missing or not a proper web uri: ${url}`\n    )\n  }\n\n  if (totalJobs === 0) {\n    bar = createProgress(`Downloading remote files`, reporter)\n    bar.start()\n  }\n\n  totalJobs += 1\n\n  bar.total = totalJobs\n\n  const fileDownloadPromise = pushTask({\n    url,\n    cache,\n    createNode,\n    parentNodeId,\n    createNodeId,\n    auth,\n    httpHeaders,\n    ext,\n    name,\n  })\n\n  processingCache[url] = fileDownloadPromise.then((node) => {\n    bar.tick()\n\n    return node\n  })\n\n  return processingCache[url]\n}\n"],"file":"index.js"}