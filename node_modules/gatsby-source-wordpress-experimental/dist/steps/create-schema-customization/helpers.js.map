{"version":3,"sources":["../../../src/steps/create-schema-customization/helpers.js"],"names":["buildTypeName","name","schema","typePrefix","prefix","findTypeName","type","ofType","findTypeKind","kind","fieldOfTypeWasFetched","fetchedTypes","store","getState","remoteSchema","typeName","typeWasFetched","get","supportedScalars","typeIsABuiltInScalar","includes","typeIsASupportedScalar","getTypeSettingsByType","allTypeSettings","gatsbyApi","pluginOptions","__allTypeSetting","__all","typeSettings","filterTypeDefinition","typeDefinition","typeBuilderApi","typeKind","filters","typeDefinitionFilters","filter","length","forEach","typeDef"],"mappings":"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","sourcesContent":["import store from \"~/store\"\nimport { typeDefinitionFilters } from \"./type-filters\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\n\n/**\n * This function namespaces typenames with a prefix\n */\nexport const buildTypeName = (name) => {\n  if (!name || typeof name !== `string`) {\n    return null\n  }\n\n  const {\n    schema: { typePrefix: prefix },\n  } = getPluginOptions()\n\n  // this is for our namespace type on the root { wp { ...fields } }\n  if (name === prefix) {\n    return name\n  }\n\n  return prefix + name\n}\n\n/**\n * Find the first type name of a Type definition pulled via introspection\n * @param {object} type\n */\nexport const findTypeName = (type) =>\n  type?.name ||\n  type?.ofType?.name ||\n  type?.ofType?.ofType?.name ||\n  type?.ofType?.ofType?.ofType?.name\n\n/**\n * Find the first type kind of a Type definition pulled via introspection\n * @param {object} type\n */\nexport const findTypeKind = (type) =>\n  type?.kind ||\n  type?.ofType?.kind ||\n  type?.ofType?.ofType?.kind ||\n  type?.ofType?.ofType?.ofType?.kind\n\nexport const fieldOfTypeWasFetched = (type) => {\n  const { fetchedTypes } = store.getState().remoteSchema\n  const typeName = findTypeName(type)\n  const typeWasFetched = !!fetchedTypes.get(typeName)\n\n  return typeWasFetched\n}\n\nconst supportedScalars = [\n  `Int`,\n  `Float`,\n  `String`,\n  `Boolean`,\n  `ID`,\n  `Date`,\n  `JSON`,\n]\n\nexport const typeIsABuiltInScalar = (type) =>\n  // @todo the next function and this one are redundant.\n  // see the next todo on how to fix the issue. If that todo is resolved, these functions will be identical. :(\n  supportedScalars.includes(findTypeName(type))\n\nexport const typeIsASupportedScalar = (type) => {\n  if (findTypeKind(type) !== `SCALAR`) {\n    // @todo returning true here seems wrong since a type that is not a scalar can't be a supported scalar... so there is some other logic elsewhere that is wrong\n    // making this return false causes errors in the schema\n    return true\n  }\n\n  return supportedScalars.includes(findTypeName(type))\n}\n\n// retrieves plugin settings for the provided type\nexport const getTypeSettingsByType = (type) => {\n  if (!type) {\n    return {}\n  }\n\n  // the plugin options object containing every type setting\n  const allTypeSettings = store.getState().gatsbyApi.pluginOptions.type\n\n  // the type.__all plugin option which is applied to every type setting\n  const __allTypeSetting = allTypeSettings.__all || {}\n\n  const typeName = findTypeName(type)\n  const typeSettings = allTypeSettings[typeName]\n\n  if (typeSettings) {\n    return { ...__allTypeSetting, ...typeSettings }\n  }\n\n  return __allTypeSetting\n}\n\n/**\n * This is used to filter the automatically generated type definitions before they're added to the schema customization api.\n */\nexport const filterTypeDefinition = (\n  typeDefinition,\n  typeBuilderApi,\n  typeKind\n) => {\n  const filters = typeDefinitionFilters.filter((filter) =>\n    [typeBuilderApi.type.name, `__all`].includes(filter.typeName)\n  )\n\n  if (filters?.length) {\n    filters.forEach((filter) => {\n      if (filter && typeof filter.typeDef === `function`) {\n        typeDefinition = filter.typeDef(\n          typeDefinition,\n          typeBuilderApi,\n          typeKind\n        )\n      }\n    })\n  }\n\n  return typeDefinition\n}\n"],"file":"helpers.js"}